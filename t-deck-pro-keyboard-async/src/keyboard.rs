//! Core implementation of the TCA8418 keyboard scanner driver.

use embassy_time::{Duration, Timer};
use embedded_hal_async::i2c::{I2c, SevenBitAddress};
use esp_hal::gpio::{Input, Output};
use heapless::Vec;

const I2C_ADDRESS: u8 = 0x34;

// TCA8418 Registers
const REG_CFG: u8 = 0x01;
const REG_INT_STAT: u8 = 0x02;
const REG_KEY_LCK_EC: u8 = 0x03;
const REG_KEY_EVENT_A: u8 = 0x04;
const REG_KP_GPIO1: u8 = 0x1D;
const REG_KP_GPIO2: u8 = 0x1E;
const REG_KP_GPIO3: u8 = 0x1F;

// Special character definitions for modifier keys.
// These are not expected to be received by themselves.
const ALT: char = '\u{1}';
const L_SHIFT: char = '\u{2}';
const R_SHIFT: char = '\u{3}';

/// The backspace key character.
pub const BACKSPACE: char = '\u{8}';
/// The enter key character.
pub const ENTER: char = '\n';
/// The microphone key character.
pub const MIC: char = '\u{4}';
/// The space key character.
pub const SPACE: char = ' ';
/// The symbol key character.
pub const SYM: char = '\u{5}';

// Base keymap for the T-Deck keyboard.
// '\0' is used for keys that are not physically present or should not produce output.
const KEYMAP: [[char; 10]; 4] = [
    ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'],
    ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', BACKSPACE],
    [ALT, 'z', 'x', 'c', 'v', 'b', 'n', 'm', '$', ENTER],
    [
        '\0', '\0', '0', '\0', '(', L_SHIFT, MIC, SPACE, SYM, R_SHIFT,
    ],
];

// Keymap when the ALT modifier is active.
const KEYMAP_ALT: [[char; 10]; 4] = [
    ['#', '1', '2', '3', '(', ')', '_', '-', '+', '@'],
    ['*', '4', '5', '6', '/', ':', ';', '\'', '"', BACKSPACE],
    [ALT, '7', '8', '9', '?', '!', ',', '.', '%', ENTER],
    [
        '\0', '\0', '0', '\0', '(', L_SHIFT, MIC, SPACE, SYM, R_SHIFT,
    ],
];

/// Represents the state of a key.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum KeyState {
    /// A key was pressed down.
    Down,
    /// A key was released.
    Up,
}

/// Bitmask for the left shift modifier.
pub const MOD_L_SHIFT: u8 = 0b0000_0001;
/// Bitmask for the right shift modifier.
pub const MOD_R_SHIFT: u8 = 0b0000_0010;
/// Bitmask for the alt modifier.
pub const MOD_ALT: u8 = 0b0000_0100;

/// Represents a single, complete key event, including the character and its state.
#[derive(Debug, Clone, Copy)]
pub struct KeyEvent {
    /// The character generated by the key press.
    pub key: char,
    /// The state of the key (pressed or released).
    pub state: KeyState,
    /// A bitmask of the active modifiers (e.g., `MOD_L_SHIFT`).
    pub modifiers: u8,
}

/// A controller for the TCA8418 keyboard scanner.
pub struct KeyboardController<
    'a,
    I2cType: I2c<SevenBitAddress, Error = ErrorType>,
    ErrorType: embedded_hal_async::i2c::Error,
> {
    i2c: I2cType,
    int: Input<'a>,
    rst: Option<Output<'a>>,
    l_shift_pressed: bool,
    r_shift_pressed: bool,
    alt_pressed: bool,
    first_key_event: Option<KeyEvent>,
    keys_down_count: u8,
}

impl<
        'a,
        I2cType: I2c<SevenBitAddress, Error = ErrorType>,
        ErrorType: embedded_hal_async::i2c::Error,
    > KeyboardController<'a, I2cType, ErrorType>
{
    /// Creates a new `KeyboardController`.
    ///
    /// # Arguments
    ///
    /// * `i2c` - An I2C peripheral that implements `embedded-hal-async::i2c::I2c`.
    /// * `int` - The interrupt input pin from the keyboard controller.
    /// * `rst` - An optional output pin for resetting the controller.
    pub fn new(i2c: I2cType, int: Input<'a>, rst: Option<Output<'a>>) -> Self {
        Self {
            i2c,
            int,
            rst,
            l_shift_pressed: false,
            r_shift_pressed: false,
            alt_pressed: false,
            first_key_event: None,
            keys_down_count: 0,
        }
    }

    /// Checks if a key is currently pressed by reading the interrupt pin state.
    pub fn is_key_pressed(&self) -> bool {
        self.int.is_low()
    }

    /// Initializes the keyboard controller.
    ///
    /// This function resets the TCA8418, configures the keypad matrix pins,
    /// enables interrupts, and clears the initial interrupt status.
    pub async fn init(&mut self) -> Result<(), ()> {
        if let Some(rst) = &mut self.rst {
            rst.set_low();
            Timer::after(Duration::from_millis(10)).await;
            rst.set_high();
            Timer::after(Duration::from_millis(100)).await;
        }

        // Configure Rows 0-3 and Columns 0-9 for the keypad matrix
        self.write_reg(REG_KP_GPIO1, 0x0F).await?;
        self.write_reg(REG_KP_GPIO2, 0xFF).await?;
        self.write_reg(REG_KP_GPIO3, 0x03).await?;

        // Configure operating mode: enable keypad event interrupt and overflow interrupt
        if let Err(err) = self.write_reg(REG_CFG, 0x09).await {
            log::warn!("Error writing REG_CFG: {err:?}");
        }
        // Clear any pending interrupts
        self.write_reg(REG_INT_STAT, 0xFF).await?;

        Ok(())
    }

    /// Reads and processes key events from the controller's FIFO buffer.
    ///
    /// This function waits for an interrupt, reads the event buffer from the
    /// TCA8418, and translates the raw key codes into `KeyEvent`s. It handles
    /// modifier keys (Shift, Alt) and returns a vector of events.
    pub async fn read_key_events(&mut self) -> Result<Vec<KeyEvent, 10>, ()> {
        self.int.wait_for_low().await;

        let mut events = Vec::new();
        let mut int_stat = [0u8];
        self.i2c
            .write_read(I2C_ADDRESS, &[REG_INT_STAT], &mut int_stat)
            .await
            .map_err(|_| ())?;

        // Check if it's a Key Event Interrupt
        if (int_stat[0] & 0x01) != 0 {
            let mut key_lck_ec = [0u8];
            self.i2c
                .write_read(I2C_ADDRESS, &[REG_KEY_LCK_EC], &mut key_lck_ec)
                .await
                .map_err(|_| ())?;

            let event_count = key_lck_ec[0] & 0x0F;

            for _ in 0..event_count {
                let mut key_event_buf = [0u8];
                self.i2c
                    .write_read(I2C_ADDRESS, &[REG_KEY_EVENT_A], &mut key_event_buf)
                    .await
                    .map_err(|_| ())?;

                let key_event = key_event_buf[0];
                if key_event != 0 {
                    let state = if key_event & 0x80 != 0 {
                        KeyState::Down
                    } else {
                        KeyState::Up
                    };
                    let key_code = (key_event & 0x7F) - 1;
                    let row = (key_code / 10) as usize;
                    let col = 9 - (key_code % 10) as usize;

                    if row < 4 && col < 10 {
                        let mut key = if self.alt_pressed {
                            KEYMAP_ALT[row][col]
                        } else {
                            KEYMAP[row][col]
                        };

                        match state {
                            KeyState::Down => self.keys_down_count += 1,
                            KeyState::Up => {
                                self.keys_down_count = self.keys_down_count.saturating_sub(1)
                            }
                        }

                        match key {
                            L_SHIFT => self.l_shift_pressed = state == KeyState::Down,
                            R_SHIFT => self.r_shift_pressed = state == KeyState::Down,
                            ALT => self.alt_pressed = state == KeyState::Down,
                            _ => {
                                if key != '\0'
                                    && state == KeyState::Down
                                    && self.first_key_event.is_none()
                                {
                                    let shift_pressed =
                                        self.l_shift_pressed || self.r_shift_pressed;
                                    if shift_pressed && key.is_ascii_alphabetic() {
                                        key = key.to_ascii_uppercase();
                                    }

                                    let mut modifiers = 0;
                                    if self.l_shift_pressed {
                                        modifiers |= MOD_L_SHIFT;
                                    }
                                    if self.r_shift_pressed {
                                        modifiers |= MOD_R_SHIFT;
                                    }
                                    if self.alt_pressed {
                                        modifiers |= MOD_ALT;
                                    }

                                    self.first_key_event = Some(KeyEvent {
                                        key,
                                        state: KeyState::Down,
                                        modifiers,
                                    });
                                }
                            }
                        }
                    }
                }
            }

            // Clear the interrupt
            self.write_reg(REG_INT_STAT, 0xFF).await?;
        }

        if self.keys_down_count == 0 {
            if let Some(mut event) = self.first_key_event.take() {
                event.state = KeyState::Up;
                events.push(event).unwrap();
            }
        }

        Ok(events)
    }

    /// Writes a value to a specific register on the TCA8418.
    async fn write_reg(&mut self, reg: u8, value: u8) -> Result<(), ()> {
        self.i2c
            .write(I2C_ADDRESS, &[reg, value])
            .await
            .map_err(|err| {
                log::warn!("Error writing to register {reg:#02x}: {err:?}");
            })
    }
}
